import torch
import torch.nn as nn
import matplotlib.pyplot as plt
from old_torch_RNNmodel import RNNModel  # Assuming this is your custom module

# Function to create sequences and targets
def create_sequences(data, sequence_length):
    sequences = []
    targets = []
    for i in range(len(data) - sequence_length):
        seq = data[i:i+sequence_length]
        target = data[i+sequence_length]
        sequences.append(seq)
        targets.append(target)
    return torch.tensor(sequences, dtype=torch.float32), torch.tensor(targets, dtype=torch.float32)

# Generate training and testing data
train_data = [float(i) for i in range(1, 100)]
test_data = [float(i) for i in range(100,200)]

# Create sequences and targets
sequence_length = 3  # You can experiment with different sequence lengths
train_sequences, train_targets = create_sequences(train_data, sequence_length)
test_sequences, test_targets = create_sequences(test_data, sequence_length)

# Initialize model, criterion, and optimizer
model = RNNModel(input_size=1, hidden_size=100, num_layers=2, output_size=1)
criterion = nn.MSELoss()
optimizer = torch.optim.Adam(model.parameters(), lr=0.01)

# Training loop
num_epochs = 400  # Adjust the number of epochs as needed
for epoch in range(num_epochs):
    model.train()
    optimizer.zero_grad()
    outputs = model(train_sequences.unsqueeze(-1))
    loss = criterion(outputs, train_targets.unsqueeze(-1).view(-1, 1))  # Reshape targets to match output
    loss.backward()
    optimizer.step()
    print(f'Epoch [{epoch+1}/{num_epochs}], Loss: {loss.item():.4f}')

# Testing loop
model.eval()
test_losses = []
actuals = []
predictions = []

with torch.no_grad():
    for i in range(len(test_sequences)):
        input_seq = test_sequences[i].unsqueeze(0).unsqueeze(-1)
        target = test_targets[i]
        output = model(input_seq)
        loss = criterion(output, target.unsqueeze(-1).view(-1, 1))  # Reshape target to match output
        test_losses.append(loss.item())
        actuals.append(target.item())
        predictions.append(output.item())

average_test_loss = sum(test_losses) / len(test_losses)
print(f'Average Test Loss: {average_test_loss:.4f}')

# Plot function
def plot():
    plt.figure(figsize=(12, 6))
    plt.plot(actuals, label='Actual')
    plt.plot(predictions, label='Predicted')
    plt.title('Test Actual vs Test Predicted')
    plt.xlabel('Sample')
    plt.ylabel('Value')
    plt.legend()
    plt.show()

plot()
